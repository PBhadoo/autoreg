#!/usr/local/bin/python
# $Id$
#
# Gets on stdin :
# 1)    a domain name
# 2)    lines giving, for each server, its fqdn and
#       (optionally) its IP address.
#
#       -- OR --
#
# Gets a domain name in argument then retrieves the NS list on the Internet.
#
# Checks :
# 1)    IP addresses of servers not in domain
# 2)    primary and secondaries are authoritative for the domain
# 3)    NS records for domain on all listed server match the provided list.
#

import getopt
import re
import socket
import sys

import dns
import dns.ipv6
import dns.message
import dns.query
import dns.rdatatype
import dns.resolver

def sendquery(q, server):
  trytcp = False
  try:
    r = dns.query.udp(q, server, timeout=10)
  except dns.query.BadResponse:
    return None, "BadResponse"
  except dns.query.UnexpectedSource:
    return None, "UnexpectedSource"
  except dns.exception.Timeout:
    trytcp = True
  except socket.error, e:
    return None, e

  if not trytcp:
    return True, r

  try:
    r = dns.query.tcp(q, server, timeout=10)
  except dns.query.BadResponse:
    return None, "BadResponse"
  except dns.query.UnexpectedSource:
    return None, "UnexpectedSource"
  except EOFError:
    return None, "Dropped connection"
  except dns.exception.Timeout:
    return None, "Timeout"
  except socket.error, e:
    return None, e

  return True, r

def getsoa(qsoa, server):
  """Send SOA query to server and wait for reply.
     Return master name and serial.
  """
  ok, r = sendquery(qsoa, server)
  if not ok:
    return None, r
  if (r.flags & dns.flags.AA) == 0:
    return None, "Answer not authoritative"
  if len(r.answer) == 0:
    return None, "Empty answer"
  if len(r.answer) != 1:
    return None, "Unexpected answer length"
  if len(r.answer[0].items) != 1:
    return None, "Unexpected number of items"
  if r.answer[0].items[0].rdtype != dns.rdatatype.SOA:
    return None, "Answer type mismatch"
  mastername = r.answer[0].items[0].mname.__str__().upper()
  serial = r.answer[0].items[0].serial
  return True, (mastername, serial)

def getnslist(domaindot, server):
  qns = dns.message.make_query(domaindot, 'NS')
  qns.flags = 0
  ok, r = sendquery(qns, server)
  if not ok:
    return None, r
  if (r.flags & dns.flags.AA) == 0:
    return None, "Answer not authoritative"
  if len(r.answer) == 0:
    return None, "Empty answer"
  if len(r.answer) != 1:
    return None, "Unexpected answer length"
  nslist = []
  for a in r.answer[0].items:
    v = a.to_text().upper()
    if v.endswith('.'):
      v = v[:-1]
    nslist.append(v)
  nslist.sort()
  return True, nslist

def getnslist_public(domaindot, res):
  tcp = False
  nslist = []
  try:
    ans = res.query(domaindot, 'NS', tcp=tcp)
  except dns.resolver.NXDOMAIN:
    return None, "Error: Domain not found"
  except dns.exception.Timeout:
    return None, "Error: Timeout"
  except dns.resolver.NoAnswer:
    return None, "Error: No answer"
  except dns.resolver.NoNameservers:
    return None, "Error: No name servers"
  for i in ans.rrset.items:
    fqdn = i.to_text().upper()
    if fqdn.endswith('.'):
      fqdn = fqdn[:-1]
    nslist.append(fqdn)
  nslist.sort()
  return True, nslist

def getnslist_file(file):
  fqdnip = re.compile('^([a-zA-Z0-9\.-]+)(?:\s+(\S+))?\s*$')
  errlist = []
  warnlist = []
  fqdnlist = []
  for l in file:
    l = l[:-1]
    m = fqdnip.match(l)
    if not m:
      errlist.append("Error: Invalid line")
      continue
    fqdn, ip = m.groups()
    if ip is not None:
      ip = ip.upper()

      try:
        if ':' in ip:
          socket.inet_pton(socket.AF_INET6, ip)
        else:
          socket.inet_pton(socket.AF_INET, ip)
      except socket.error:
        errlist.append("Error: Invalid IP address %s" % ip)
        ip = None

    if ip is not None:
      if fqdn.endswith('.'+domain) or fqdn == domain:
        manualip[fqdn] = ip
      else:
        warnlist.append("Warning: ignoring IP %s for %s (not in %s)" % (ip, fqdn, domain))

    fqdn = fqdn.upper()
    fqdnlist.append(fqdn)

  return errlist, warnlist, fqdnlist

def resolve_ips(res, fqdnlist, manualip):
  tcp = False
  ips = []
  errs = 0
  for fqdn in fqdnlist:
    if fqdn.endswith('.'):
      fqdn = fqdn[:-1]

    if fqdn in manualip:
      print "Accepted IP for %s: %s" % (fqdn, manualip[fqdn])
      ips.append((fqdn, manualip[fqdn]))
      continue

    print "Getting IP for %s..." % fqdn,
    n = 0
    for t in ['A', 'AAAA']:
      try:
        aip = res.query(fqdn, t, tcp=tcp)
      except dns.resolver.NoAnswer:
        continue
      except dns.resolver.NXDOMAIN:
        continue
      except dns.exception.Timeout:
        continue
      except dns.resolver.NoNameservers:
        continue
      for iprr in aip.rrset.items:
        print iprr.to_text(),
        ips.append((fqdn, iprr.to_text()))
        n += 1
    if n == 0:
      print "FAILED",
      errs += 1
    print
  return errs, ips

def check_soa(domaindot, ips):
  errs = 0
  warns = 0
  qsoa = dns.message.make_query(domaindot, 'SOA')
  qsoa.flags = 0
  for fqdnip in ips:
    fqdn, i = fqdnip
    print "Getting SOA from %s at %s..." % (fqdn, i),
    ok, soa = getsoa(qsoa, i)
    if not ok:
      print "Error:", soa
      errs += 1
    else:
      print "serial", soa[1]
  return errs, warns

def check_ns(domaindot, fqdnlist, mastername, ips):
  errs = 0
  warns = 0
  for fqdnip in ips:
    fqdn, i = fqdnip
    print "Getting NS from %s at %s..." % (fqdn, i),
    ok, nslist = getnslist(domaindot, i)
    if not ok:
      print "Error:", nslist
      errs += 1
    elif nslist != fqdnlist:
      if mastername and mastername == fqdn:
        print "Error: Bad NS list", nslist
        errs += 1
      else:
        print "Warning: Bad NS list", nslist
        warns += 1
    else:
      print "ok"
  return errs, warns

def main():
  errs = 0
  warns = 0
  fqdnlist = []
  res = dns.resolver.Resolver()
  manualip = { }
  mastername = None

  try:
    optlist, args = getopt.getopt(sys.argv[1:], 'o:')
  except getopt.GetoptError, err:
    print str(err)
    sys.exit(2)

  for opt, val in optlist:
    if opt == '-o':
      fqdn, ip = val.split('=')
      try:
        if ':' in ip:
          socket.inet_pton(socket.AF_INET6, ip)
        else:
          socket.inet_pton(socket.AF_INET, ip)
      except socket.error:
        print "Error: Invalid IP address", ip
        ip = None
        errs += 1
      manualip[fqdn.upper()] = ip

  print "---- Servers and domain names check"
  print

  if len(args) == 1:
    domain = args[0].upper()
  else:
    # Fetch domain from stdin
    domain = sys.stdin.readline()
    domain = domain[:-1].upper()

  if domain.startswith('.'):
    domain = domain[1:]
  domaindot = domain
  if domain.endswith('.'):
    domain = domain[:-1]
  else:
    domaindot += '.'

  if len(args) == 1:
    #
    # Fetch NS list from public DNS
    #
    print "Querying NS list for %s..." % domain,
    ok, r = getnslist_public(domaindot, res)
    if not ok:
      print r
      sys.exit(1)
    fqdnlist = r
    print len(fqdnlist), "records"
    print

  else:
    #
    # Fetch NS list from stdin
    #
    errlist, warnlist, fqdnlist = getnslist_file(sys.stdin)
    if fqdnlist:
      mastername = fqdnlist[0]

    for e in errlist:
      print "Error: ", e
    errs += len(errlist)
    for e in warnlist:
      print "Warning: ", e
    warns += len(warnlist)

  if not domain:
    print "Error: no domain specified"
    errs += 1
  if not fqdnlist:
    print "Error: empty name server list"
    errs += 1

  if errs:
    print errs, "errors(s)",
    sys.exit(1)

  fqdnlist.sort()

  #
  # Build IP address list
  #

  errs, ips = resolve_ips(res, fqdnlist, manualip)
  if errs:
    print errs, "errors(s)",
    sys.exit(1)

  print
  print "---- Checking SOA & NS records for", domain
  print

  errs2, warns2 = check_soa(domaindot, ips)
  errs += errs2
  warns += warns2

  errs2, warns2 = check_ns(domaindot, fqdnlist, mastername, ips)
  errs += errs2
  warns += warns2

  if errs or warns:
    print
  if errs:
    print errs, "errors(s)",
  if warns:
    print warns, "warning(s)",
  print
  if errs:
    sys.exit(1)
  sys.exit(0)

if __name__ == "__main__":
  main()
