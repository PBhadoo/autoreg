#!/usr/bin/perl
#
# $Id$
#
# script to handle a mailed form and pipe it to $CRPATH
#

require "getopts.pl";
do Getopts("l:");

if ($#ARGV != -1) { die "Usage: receive-mail [-l language-iso-code]\n"; }

if ($opt_l eq 'fr') {
	$ENV{'LANG'}="fr";
} else {
	$ENV{'LANG'}="en";
}

# local configuration
require "/usr/local/autoreg/conf/config";
require "$DNSCONF/msg-val";
require "$DNSLIB/requests.pl";

#
# Create a temporary request file
#
$REQFILE="$REQDIR/mail-$$";

$headers = 1;

open(WF, ">$REQFILE") || die "Cannot open $REQFILE: $!\n";
open(VF, "| $SENDMAIL -t") || die "Cannot start sendmail: $!\n";

$thdrs = "";

while (<STDIN>) {
	$thdrs .= $_;
	chop;

	if (/^\s/)	{ $line .= $_; next; }
	if (/^$/)	{ $headers = 0; }

	$lline = $line; $line = $_;

	if ($lline =~ /^([A-Za-z0-9-]+):\s+(.*)\s*$/) {
		$hd = $1;
		$cn = $2;
		$hd =~ tr/A-Z/a-z/;
	} else {
		$hd = "";
	}

	if ($hd eq "from")		{ $from=$cn; }
	elsif ($hd eq "reply-to")	{ $replyto=$cn; }
	elsif ($hd eq "subject")	{ $subject=$cn; }
	elsif ($hd eq "x-loop")		{ die "Loop detected\n"; }

	last unless $headers;
}

if ($headers) {
	die "Premature end of mail.\n";
}

print VF "X-Loop: ns.eu.org\n";


if (!$replyto) { $replyto = $from; }
if (!$replyto) {
	close(WF);
	unlink($REQFILE);
	die "Error: no identified sender.\n";
}

# quick & dirty RFC822 comment parsing
if ($replyto =~ /[^<]*<([^>]+)>/) {
	$replyto = $1;
}
if ($replyto =~ /^(.*\S)\s*\(.*\)/) {
	$replyto = $1;
}
if ($replyto =~ /^majordomo/i || $replyto =~ /^mailer-daemon/i) {
	open(LO, ">> /tmp/receive-mail.log");
	print LO "from=$from\nreplyto=$replyto\n";
	close LO;
	exit 0;
}

printf VF $MAILHEADERS, $MSG_ADDR;
print VF "To: $replyto\n";
print WF "mr.: $replyto\n";

print WF $thdrs;

#
# Copy the mail body to WF, removing all leading garbage
# to account for quoted replies, etc.
#
while (<STDIN>) {
	s/^[^a-zA-Z0-9]*//;
	print WF;
}
close(WF);

#
# Try to process aknowledgement mails
#
local ($rqid) = &rq_extract($subject);
if ($rqid) {
  # A valid request id has been found in the Subject:

  if ($subject =~ /^R[eE]: /) {
    print VF "Subject: $subject\n";
  } else {
    print VF "Subject: Re: $subject\n";
  }

  if (!&rq_exists($rqid)) {
    # The request does not exist
    printf VF $MSG_ACKKO, $rqid;

    # Continue anyway, to find out if it's a valid form and process it

  } else {
    # The request exists: read it and check its state
    ($error, $replyto, $action, $domain, $lang, $state, $dns, $dbrecords)
	= &rq_get_info($rqid, "DNSADMIN");
    if ($state eq "WaitAck") {
      # Change its state to "Open"
      &rq_set_state($rqid, "DNSADMIN", "Open", "");
    }
    # notify the requester

    printf VF $MSG_ACKOK, $rqid;
    print  VF $MSG_BYE;
    close(VF);

    if ($action eq 'MZ') {
	system "/usr/local/autoreg/bin/doaccept $rqid >> /tmp/doaccept.log";
    }

    die "Error sending mail: $!\n" if $?;

    unlink($REQFILE);
    exit 0;
  }
}

#
# No valid request id found in the subject, assume it's a new request
#
open(CHECK, "$CRPATH -s -l$ENV{'LANG'} < $REQFILE mail 2>&1 |") || die "Cannot start $CRPATH: $!\n";
while (<CHECK>) {
	print VF;
}
close(CHECK);

close(VF);
die "Error sending mail: $!\n" if $?;

unlink($REQFILE);
